// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: emissions/v1/params.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_allora_network_allora_chain_math "github.com/allora-network/allora-chain/math"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters of the module.
type Params struct {
	Version                         string                                          `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	MaxSerializedMsgLength          int64                                           `protobuf:"varint,2,opt,name=max_serialized_msg_length,json=maxSerializedMsgLength,proto3" json:"max_serialized_msg_length,omitempty"`
	MinTopicWeight                  github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,3,opt,name=min_topic_weight,json=minTopicWeight,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"min_topic_weight"`
	MaxTopicsPerBlock               uint64                                          `protobuf:"varint,4,opt,name=max_topics_per_block,json=maxTopicsPerBlock,proto3" json:"max_topics_per_block,omitempty"`
	MaxMissingInferencePercent      github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,5,opt,name=max_missing_inference_percent,json=maxMissingInferencePercent,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"max_missing_inference_percent"`
	RequiredMinimumStake            cosmossdk_io_math.Int                           `protobuf:"bytes,6,opt,name=required_minimum_stake,json=requiredMinimumStake,proto3,customtype=cosmossdk.io/math.Int" json:"required_minimum_stake"`
	RemoveStakeDelayWindow          int64                                           `protobuf:"varint,7,opt,name=remove_stake_delay_window,json=removeStakeDelayWindow,proto3" json:"remove_stake_delay_window,omitempty"`
	MinEpochLength                  int64                                           `protobuf:"varint,8,opt,name=min_epoch_length,json=minEpochLength,proto3" json:"min_epoch_length,omitempty"`
	BetaEntropy                     github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,9,opt,name=beta_entropy,json=betaEntropy,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"beta_entropy"`
	LearningRate                    github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,10,opt,name=learning_rate,json=learningRate,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"learning_rate"`
	MaxGradientThreshold            github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,11,opt,name=max_gradient_threshold,json=maxGradientThreshold,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"max_gradient_threshold"`
	MinStakeFraction                github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,12,opt,name=min_stake_fraction,json=minStakeFraction,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"min_stake_fraction"`
	Epsilon                         github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,13,opt,name=epsilon,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"epsilon"`
	AlphaRegret                     github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,14,opt,name=alpha_regret,json=alphaRegret,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"alpha_regret"`
	MaxUnfulfilledWorkerRequests    uint64                                          `protobuf:"varint,15,opt,name=max_unfulfilled_worker_requests,json=maxUnfulfilledWorkerRequests,proto3" json:"max_unfulfilled_worker_requests,omitempty"`
	MaxUnfulfilledReputerRequests   uint64                                          `protobuf:"varint,16,opt,name=max_unfulfilled_reputer_requests,json=maxUnfulfilledReputerRequests,proto3" json:"max_unfulfilled_reputer_requests,omitempty"`
	TopicRewardStakeImportance      github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,17,opt,name=topic_reward_stake_importance,json=topicRewardStakeImportance,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"topic_reward_stake_importance"`
	TopicRewardFeeRevenueImportance github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,18,opt,name=topic_reward_fee_revenue_importance,json=topicRewardFeeRevenueImportance,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"topic_reward_fee_revenue_importance"`
	// 0.5
	TopicRewardAlpha github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,19,opt,name=topic_reward_alpha,json=topicRewardAlpha,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"topic_reward_alpha"`
	// updates
	TaskRewardAlpha                 github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,20,opt,name=task_reward_alpha,json=taskRewardAlpha,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"task_reward_alpha"`
	ValidatorsVsAlloraPercentReward github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,21,opt,name=validators_vs_allora_percent_reward,json=validatorsVsAlloraPercentReward,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"validators_vs_allora_percent_reward"`
	MaxSamplesToScaleScores         uint64                                          `protobuf:"varint,22,opt,name=max_samples_to_scale_scores,json=maxSamplesToScaleScores,proto3" json:"max_samples_to_scale_scores,omitempty"`
	MaxTopInferersToReward          uint64                                          `protobuf:"varint,23,opt,name=max_top_inferers_to_reward,json=maxTopInferersToReward,proto3" json:"max_top_inferers_to_reward,omitempty"`
	MaxTopForecastersToReward       uint64                                          `protobuf:"varint,24,opt,name=max_top_forecasters_to_reward,json=maxTopForecastersToReward,proto3" json:"max_top_forecasters_to_reward,omitempty"`
	MaxTopReputersToReward          uint64                                          `protobuf:"varint,25,opt,name=max_top_reputers_to_reward,json=maxTopReputersToReward,proto3" json:"max_top_reputers_to_reward,omitempty"`
	CreateTopicFee                  cosmossdk_io_math.Int                           `protobuf:"bytes,26,opt,name=create_topic_fee,json=createTopicFee,proto3,customtype=cosmossdk.io/math.Int" json:"create_topic_fee"`
	SigmoidA                        github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,27,opt,name=sigmoid_a,json=sigmoidA,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"sigmoid_a"`
	SigmoidB                        github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,28,opt,name=sigmoid_b,json=sigmoidB,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"sigmoid_b"`
	GradientDescentMaxIters         uint64                                          `protobuf:"varint,29,opt,name=gradient_descent_max_iters,json=gradientDescentMaxIters,proto3" json:"gradient_descent_max_iters,omitempty"`
	MaxRetriesToFulfilNoncesWorker  int64                                           `protobuf:"varint,30,opt,name=max_retries_to_fulfil_nonces_worker,json=maxRetriesToFulfilNoncesWorker,proto3" json:"max_retries_to_fulfil_nonces_worker,omitempty"`
	MaxRetriesToFulfilNoncesReputer int64                                           `protobuf:"varint,31,opt,name=max_retries_to_fulfil_nonces_reputer,json=maxRetriesToFulfilNoncesReputer,proto3" json:"max_retries_to_fulfil_nonces_reputer,omitempty"`
	TopicPageLimit                  uint64                                          `protobuf:"varint,32,opt,name=topic_page_limit,json=topicPageLimit,proto3" json:"topic_page_limit,omitempty"`
	MaxTopicPages                   uint64                                          `protobuf:"varint,33,opt,name=max_topic_pages,json=maxTopicPages,proto3" json:"max_topic_pages,omitempty"`
	RegistrationFee                 cosmossdk_io_math.Int                           `protobuf:"bytes,34,opt,name=registration_fee,json=registrationFee,proto3,customtype=cosmossdk.io/math.Int" json:"registration_fee"`
	DefaultLimit                    uint64                                          `protobuf:"varint,35,opt,name=default_limit,json=defaultLimit,proto3" json:"default_limit,omitempty"`
	MaxLimit                        uint64                                          `protobuf:"varint,36,opt,name=max_limit,json=maxLimit,proto3" json:"max_limit,omitempty"`
	MinEpochLengthRecordLimit       int64                                           `protobuf:"varint,37,opt,name=min_epoch_length_record_limit,json=minEpochLengthRecordLimit,proto3" json:"min_epoch_length_record_limit,omitempty"`
	// block emission rate in number of blocks expected per month
	BlocksPerMonth   uint64                                          `protobuf:"varint,38,opt,name=blocks_per_month,json=blocksPerMonth,proto3" json:"blocks_per_month,omitempty"`
	PRewardInference github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,39,opt,name=p_reward_inference,json=pRewardInference,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"p_reward_inference"`
	PRewardForecast  github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,40,opt,name=p_reward_forecast,json=pRewardForecast,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"p_reward_forecast"`
	PRewardReputer   github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,41,opt,name=p_reward_reputer,json=pRewardReputer,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"p_reward_reputer"`
	CRewardInference github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,42,opt,name=c_reward_inference,json=cRewardInference,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"c_reward_inference"`
	CRewardForecast  github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,43,opt,name=c_reward_forecast,json=cRewardForecast,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"c_reward_forecast"`
	FTolerance       github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,44,opt,name=f_tolerance,json=fTolerance,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"f_tolerance"`
	CNorm            github_com_allora_network_allora_chain_math.Dec `protobuf:"bytes,45,opt,name=c_norm,json=cNorm,proto3,customtype=github.com/allora-network/allora-chain/math.Dec" json:"c_norm"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_f535e53c00d44458, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Params) GetMaxSerializedMsgLength() int64 {
	if m != nil {
		return m.MaxSerializedMsgLength
	}
	return 0
}

func (m *Params) GetMaxTopicsPerBlock() uint64 {
	if m != nil {
		return m.MaxTopicsPerBlock
	}
	return 0
}

func (m *Params) GetRemoveStakeDelayWindow() int64 {
	if m != nil {
		return m.RemoveStakeDelayWindow
	}
	return 0
}

func (m *Params) GetMinEpochLength() int64 {
	if m != nil {
		return m.MinEpochLength
	}
	return 0
}

func (m *Params) GetMaxUnfulfilledWorkerRequests() uint64 {
	if m != nil {
		return m.MaxUnfulfilledWorkerRequests
	}
	return 0
}

func (m *Params) GetMaxUnfulfilledReputerRequests() uint64 {
	if m != nil {
		return m.MaxUnfulfilledReputerRequests
	}
	return 0
}

func (m *Params) GetMaxSamplesToScaleScores() uint64 {
	if m != nil {
		return m.MaxSamplesToScaleScores
	}
	return 0
}

func (m *Params) GetMaxTopInferersToReward() uint64 {
	if m != nil {
		return m.MaxTopInferersToReward
	}
	return 0
}

func (m *Params) GetMaxTopForecastersToReward() uint64 {
	if m != nil {
		return m.MaxTopForecastersToReward
	}
	return 0
}

func (m *Params) GetMaxTopReputersToReward() uint64 {
	if m != nil {
		return m.MaxTopReputersToReward
	}
	return 0
}

func (m *Params) GetGradientDescentMaxIters() uint64 {
	if m != nil {
		return m.GradientDescentMaxIters
	}
	return 0
}

func (m *Params) GetMaxRetriesToFulfilNoncesWorker() int64 {
	if m != nil {
		return m.MaxRetriesToFulfilNoncesWorker
	}
	return 0
}

func (m *Params) GetMaxRetriesToFulfilNoncesReputer() int64 {
	if m != nil {
		return m.MaxRetriesToFulfilNoncesReputer
	}
	return 0
}

func (m *Params) GetTopicPageLimit() uint64 {
	if m != nil {
		return m.TopicPageLimit
	}
	return 0
}

func (m *Params) GetMaxTopicPages() uint64 {
	if m != nil {
		return m.MaxTopicPages
	}
	return 0
}

func (m *Params) GetDefaultLimit() uint64 {
	if m != nil {
		return m.DefaultLimit
	}
	return 0
}

func (m *Params) GetMaxLimit() uint64 {
	if m != nil {
		return m.MaxLimit
	}
	return 0
}

func (m *Params) GetMinEpochLengthRecordLimit() int64 {
	if m != nil {
		return m.MinEpochLengthRecordLimit
	}
	return 0
}

func (m *Params) GetBlocksPerMonth() uint64 {
	if m != nil {
		return m.BlocksPerMonth
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "emissions.v1.Params")
}

func init() { proto.RegisterFile("emissions/v1/params.proto", fileDescriptor_f535e53c00d44458) }

var fileDescriptor_f535e53c00d44458 = []byte{
	// 1283 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x97, 0x4d, 0x6f, 0x54, 0x37,
	0x17, 0xc7, 0x33, 0x0f, 0x10, 0x88, 0xc9, 0xab, 0x9f, 0x10, 0x9c, 0x40, 0x26, 0x79, 0x08, 0x0f,
	0x4d, 0x69, 0xc9, 0x14, 0x75, 0xd1, 0xd7, 0x45, 0x89, 0x20, 0x28, 0x2a, 0x41, 0xe9, 0xcd, 0xb4,
	0x54, 0xb4, 0x92, 0xe5, 0xdc, 0x7b, 0xe6, 0x8e, 0x95, 0x6b, 0xfb, 0xd6, 0xf6, 0x4c, 0x06, 0xf6,
	0xdd, 0xf7, 0x63, 0x74, 0xd9, 0x45, 0x97, 0xfd, 0x00, 0x2c, 0x51, 0x57, 0x55, 0x17, 0xa8, 0x82,
	0x45, 0xbf, 0x46, 0xe5, 0x97, 0x3b, 0x99, 0x81, 0xb6, 0xaa, 0xb8, 0xdd, 0x20, 0xc6, 0xfe, 0x9f,
	0xdf, 0x39, 0x39, 0xc7, 0x3e, 0xc7, 0x17, 0x2d, 0x83, 0xe0, 0xc6, 0x70, 0x25, 0x4d, 0xab, 0x7f,
	0xb3, 0x55, 0x32, 0xcd, 0x84, 0xd9, 0x2a, 0xb5, 0xb2, 0x0a, 0x4f, 0x0f, 0xb7, 0xb6, 0xfa, 0x37,
	0x57, 0x96, 0x53, 0x65, 0x84, 0x32, 0xd4, 0xef, 0xb5, 0xc2, 0x8f, 0x20, 0x5c, 0x59, 0x60, 0x82,
	0x4b, 0xd5, 0xf2, 0xff, 0xc6, 0xa5, 0xc5, 0x5c, 0xe5, 0x2a, 0x48, 0xdd, 0xff, 0xc2, 0xea, 0x95,
	0x9f, 0x2e, 0xa3, 0xc9, 0x7d, 0xef, 0x02, 0x13, 0x74, 0xb6, 0x0f, 0xda, 0xd1, 0x49, 0x63, 0xbd,
	0xb1, 0x39, 0x95, 0x54, 0x3f, 0xf1, 0x07, 0x68, 0x59, 0xb0, 0x01, 0x35, 0xa0, 0x39, 0x2b, 0xf8,
	0x63, 0xc8, 0xa8, 0x30, 0x39, 0x2d, 0x40, 0xe6, 0xb6, 0x4b, 0xfe, 0xb3, 0xde, 0xd8, 0x3c, 0x95,
	0x2c, 0x09, 0x36, 0x38, 0x18, 0xee, 0xef, 0x99, 0xfc, 0x9e, 0xdf, 0xc5, 0x0c, 0xcd, 0x0b, 0x2e,
	0xa9, 0x55, 0x25, 0x4f, 0xe9, 0x31, 0xf0, 0xbc, 0x6b, 0xc9, 0x29, 0x47, 0xdf, 0x7e, 0xef, 0xc9,
	0xb3, 0xb5, 0x89, 0x5f, 0x9f, 0xad, 0xb5, 0x72, 0x6e, 0xbb, 0xbd, 0xc3, 0xad, 0x54, 0x89, 0x16,
	0x2b, 0x0a, 0xa5, 0xd9, 0x0d, 0x09, 0xf6, 0x58, 0xe9, 0xa3, 0xea, 0x67, 0xda, 0x65, 0x5c, 0xb6,
	0x04, 0xb3, 0xdd, 0xad, 0xdb, 0x90, 0x26, 0xb3, 0x82, 0xcb, 0xb6, 0xe3, 0x3d, 0xf0, 0x38, 0xdc,
	0x42, 0x8b, 0x2e, 0x3a, 0xef, 0xc2, 0xd0, 0x12, 0x34, 0x3d, 0x2c, 0x54, 0x7a, 0x44, 0x4e, 0xaf,
	0x37, 0x36, 0x4f, 0x27, 0x0b, 0x82, 0x0d, 0xbc, 0xda, 0xec, 0x83, 0xde, 0x76, 0x1b, 0xf8, 0x31,
	0x5a, 0x75, 0x06, 0x3e, 0x95, 0x32, 0xa7, 0x5c, 0x76, 0x40, 0x83, 0x4c, 0xc1, 0xd9, 0xa6, 0x20,
	0x2d, 0x39, 0x53, 0x2f, 0xc0, 0x15, 0xc1, 0x06, 0x7b, 0x01, 0xbe, 0x5b, 0xb1, 0xf7, 0x03, 0x1a,
	0x77, 0xd0, 0x92, 0x86, 0x6f, 0x7a, 0x5c, 0xbb, 0x24, 0x72, 0xc9, 0x45, 0x4f, 0x50, 0x63, 0xd9,
	0x11, 0x90, 0x49, 0xef, 0xf4, 0x9d, 0xe8, 0xf4, 0x42, 0x28, 0xa7, 0xc9, 0x8e, 0xb6, 0xb8, 0x0a,
	0xe8, 0x5d, 0x69, 0x7f, 0xfe, 0xf1, 0x06, 0x8a, 0x75, 0xde, 0x95, 0xf6, 0xfb, 0xdf, 0x7f, 0xb8,
	0xde, 0x48, 0x16, 0x2b, 0xde, 0x5e, 0xc0, 0x1d, 0x38, 0x9a, 0x2b, 0x99, 0x06, 0xa1, 0xfa, 0x10,
	0xe8, 0x34, 0x83, 0x82, 0x3d, 0xa2, 0xc7, 0x5c, 0x66, 0xea, 0x98, 0x9c, 0x0d, 0x25, 0x0b, 0x02,
	0xaf, 0xbf, 0xed, 0xb6, 0x1f, 0xf8, 0x5d, 0xbc, 0x19, 0x4a, 0x06, 0xa5, 0x4a, 0xbb, 0x55, 0x91,
	0xcf, 0x79, 0x0b, 0x97, 0xf9, 0x3b, 0x6e, 0x39, 0x16, 0xf7, 0x21, 0x9a, 0x3e, 0x04, 0xcb, 0x28,
	0x48, 0xab, 0x55, 0xf9, 0x88, 0x4c, 0xd5, 0xcb, 0xdb, 0x79, 0x07, 0xbb, 0x13, 0x58, 0xf8, 0x6b,
	0x34, 0x53, 0x00, 0xd3, 0xd2, 0x55, 0x48, 0x33, 0x0b, 0x04, 0xd5, 0x83, 0x4f, 0x57, 0xb4, 0x84,
	0x59, 0xc0, 0x02, 0xb9, 0x03, 0x4b, 0x73, 0xcd, 0x32, 0x0e, 0xd2, 0x52, 0xdb, 0xd5, 0x60, 0xba,
	0xaa, 0xc8, 0xc8, 0xf9, 0x7a, 0x6e, 0xdc, 0x51, 0xbc, 0x1b, 0xa9, 0xed, 0x0a, 0x8a, 0x01, 0x61,
	0x97, 0xd2, 0x50, 0x8a, 0x8e, 0x66, 0xa9, 0x75, 0xb7, 0x6c, 0xba, 0x9e, 0x2b, 0x57, 0x25, 0x5f,
	0xbc, 0x9d, 0x08, 0xc4, 0x9f, 0xa1, 0xb3, 0x50, 0x1a, 0x5e, 0x28, 0x49, 0x66, 0xea, 0xb1, 0x2b,
	0x8e, 0x2b, 0x31, 0x2b, 0xca, 0x2e, 0xa3, 0x1a, 0x72, 0x0d, 0x96, 0xcc, 0xd6, 0x2c, 0xb1, 0x87,
	0x25, 0x9e, 0x85, 0xef, 0xa0, 0x35, 0x57, 0x84, 0x9e, 0xec, 0xf4, 0x8a, 0x0e, 0x2f, 0x0a, 0xc8,
	0xa8, 0x33, 0x05, 0x4d, 0xdd, 0x91, 0x06, 0x63, 0x0d, 0x99, 0xf3, 0x77, 0xf8, 0xb2, 0x60, 0x83,
	0xcf, 0x4f, 0x54, 0x0f, 0xbc, 0x28, 0x89, 0x1a, 0x7c, 0x17, 0xad, 0xbf, 0x8c, 0xd1, 0x50, 0xf6,
	0xec, 0x28, 0x67, 0xde, 0x73, 0x56, 0xc7, 0x39, 0x49, 0x50, 0x0d, 0x41, 0x8f, 0xd1, 0x6a, 0xe8,
	0x53, 0x1a, 0x8e, 0x99, 0xce, 0x62, 0xb9, 0xb8, 0x28, 0x95, 0xb6, 0x4c, 0xa6, 0x40, 0x16, 0x6a,
	0xf6, 0x05, 0x4f, 0x4f, 0x3c, 0xdc, 0x17, 0x6e, 0x77, 0x88, 0xc6, 0xdf, 0x36, 0xd0, 0xc6, 0x98,
	0xf3, 0x0e, 0x00, 0xd5, 0xd0, 0x07, 0xd9, 0x1b, 0x0b, 0x01, 0xd7, 0x0b, 0x61, 0x6d, 0x24, 0x84,
	0x1d, 0x80, 0x24, 0x38, 0x18, 0x89, 0x03, 0x10, 0x1e, 0x0b, 0xc3, 0xd7, 0x8b, 0xfc, 0xb7, 0xe6,
	0x49, 0x1d, 0xf1, 0x7a, 0xcb, 0x01, 0x71, 0x8a, 0x16, 0x2c, 0x33, 0x47, 0xe3, 0x5e, 0x16, 0xeb,
	0x79, 0x99, 0x73, 0xc4, 0x51, 0x27, 0x2e, 0xa7, 0x7d, 0x56, 0xf0, 0x8c, 0x59, 0xa5, 0x0d, 0xed,
	0x1b, 0x1a, 0x0c, 0xab, 0x3e, 0x1f, 0xbd, 0x93, 0x0b, 0x35, 0x73, 0x7a, 0xe2, 0xe3, 0x0b, 0x73,
	0xcb, 0x4b, 0x62, 0xb7, 0x0f, 0xc1, 0xe0, 0x8f, 0xd1, 0x25, 0x3f, 0x3e, 0x99, 0x28, 0x0b, 0x30,
	0xd4, 0x2a, 0x6a, 0x52, 0x56, 0x00, 0x35, 0xa9, 0xd2, 0x60, 0xc8, 0x92, 0x3f, 0x9b, 0x17, 0xdd,
	0x00, 0x0d, 0x8a, 0xb6, 0x3a, 0x70, 0xfb, 0x07, 0x7e, 0x1b, 0x7f, 0x88, 0x56, 0xe2, 0x78, 0x8b,
	0x93, 0x4a, 0x7b, 0x44, 0x8c, 0xfd, 0xa2, 0x37, 0x5e, 0x0a, 0x43, 0x6e, 0x37, 0xee, 0xb7, 0x55,
	0xf4, 0xfc, 0x49, 0x98, 0x74, 0xce, 0xb6, 0xa3, 0x34, 0xa4, 0xcc, 0xd8, 0x71, 0x73, 0xe2, 0xcd,
	0x97, 0x83, 0xf9, 0xce, 0x89, 0x64, 0x48, 0x18, 0xf1, 0x1e, 0x2f, 0xd5, 0xa8, 0xf9, 0xf2, 0xa8,
	0xf7, 0x78, 0x9d, 0x4e, 0x6c, 0x1f, 0xa2, 0xf9, 0x54, 0x03, 0xb3, 0x10, 0xc7, 0x7f, 0x07, 0x80,
	0xac, 0xbc, 0xe6, 0x94, 0x9b, 0x0d, 0x24, 0x3f, 0xc9, 0x77, 0x00, 0x70, 0x1b, 0x4d, 0x19, 0x9e,
	0x0b, 0xc5, 0x33, 0xca, 0xc8, 0xa5, 0x7a, 0x05, 0x3c, 0x17, 0x49, 0xb7, 0x46, 0xa9, 0x87, 0xe4,
	0xf2, 0xbf, 0x43, 0xdd, 0xc6, 0x1f, 0xa1, 0x95, 0xe1, 0xa0, 0xc9, 0xc0, 0xf8, 0xa3, 0xe7, 0x92,
	0xca, 0x5d, 0xb6, 0xc8, 0x6a, 0x28, 0x7f, 0xa5, 0xb8, 0x1d, 0x04, 0x7b, 0x6c, 0xb0, 0xeb, 0xb6,
	0xf1, 0xa7, 0x68, 0xc3, 0x69, 0x35, 0x58, 0xcd, 0xc3, 0xe1, 0x09, 0xfd, 0x8b, 0x4a, 0x25, 0x53,
	0x30, 0xb1, 0x63, 0x92, 0xa6, 0x1f, 0xd0, 0x4d, 0xc1, 0x06, 0x49, 0x50, 0xb6, 0xd5, 0x8e, 0xd7,
	0xdd, 0xf7, 0xb2, 0xd0, 0x32, 0xf1, 0x1e, 0xba, 0xfa, 0xb7, 0xb0, 0x58, 0x62, 0xb2, 0xe6, 0x69,
	0x6b, 0x7f, 0x45, 0x8b, 0x95, 0x76, 0x2f, 0x85, 0x50, 0xd9, 0x92, 0xe5, 0x40, 0x0b, 0x2e, 0xb8,
	0x25, 0xeb, 0xfe, 0xcf, 0x99, 0xf5, 0xeb, 0xfb, 0x2c, 0x87, 0x7b, 0x6e, 0x15, 0x5f, 0x43, 0x73,
	0xc3, 0x37, 0x9a, 0x57, 0x1b, 0xf2, 0x3f, 0x2f, 0x9c, 0xa9, 0x9e, 0x67, 0x4e, 0x6b, 0xf0, 0x57,
	0x68, 0x5e, 0x43, 0xce, 0x8d, 0xd5, 0xcc, 0x4d, 0x34, 0x7f, 0x64, 0xae, 0xbc, 0xe6, 0x91, 0x99,
	0x1b, 0x25, 0xb9, 0x33, 0xb3, 0x81, 0x66, 0x32, 0xe8, 0xb0, 0x5e, 0x61, 0x63, 0xac, 0x1b, 0x3e,
	0x84, 0xe9, 0xb8, 0x18, 0x22, 0xbd, 0x84, 0xa6, 0x5c, 0xa4, 0x41, 0x70, 0xd5, 0x0b, 0xce, 0x09,
	0x36, 0x08, 0x9b, 0xee, 0x3e, 0xbd, 0xf4, 0x34, 0xa2, 0x1a, 0x52, 0xa5, 0xb3, 0x68, 0xf0, 0x7f,
	0x9f, 0xb8, 0xe5, 0xf1, 0x77, 0x52, 0xe2, 0x15, 0x81, 0xb0, 0x89, 0xe6, 0xfd, 0xeb, 0x34, 0x3c,
	0x54, 0x85, 0x92, 0xb6, 0x4b, 0xae, 0x85, 0x94, 0x85, 0xf5, 0x7d, 0xd0, 0x7b, 0x6e, 0xd5, 0x75,
	0xe2, 0xb2, 0xea, 0x8f, 0xc3, 0x27, 0x2a, 0x79, 0xa3, 0x66, 0x27, 0x2e, 0xc3, 0xdd, 0x1c, 0xbe,
	0x4b, 0x5d, 0x27, 0x1e, 0xba, 0xa9, 0x7a, 0x04, 0xd9, 0xac, 0xd9, 0x89, 0xa3, 0x97, 0xaa, 0xa1,
	0xb8, 0xaf, 0x80, 0xa1, 0x93, 0xea, 0x8c, 0xbd, 0x59, 0xf3, 0x2b, 0x20, 0xfa, 0xa8, 0xce, 0x22,
	0x20, 0x9c, 0xbe, 0x9a, 0xae, 0xeb, 0x35, 0xd3, 0x95, 0xfe, 0x49, 0xba, 0xd2, 0x57, 0xd2, 0xf5,
	0x56, 0xcd, 0x74, 0xa5, 0x2f, 0xa5, 0xeb, 0x4b, 0x74, 0xbe, 0x43, 0xad, 0x2a, 0x40, 0xfb, 0x99,
	0xff, 0x76, 0x3d, 0x3c, 0xea, 0xb4, 0x2b, 0x14, 0xbe, 0x8f, 0x26, 0x53, 0x2a, 0x95, 0x16, 0xe4,
	0x46, 0x3d, 0xe8, 0x99, 0xf4, 0xbe, 0xd2, 0x62, 0x3b, 0x79, 0xf2, 0xbc, 0xd9, 0x78, 0xfa, 0xbc,
	0xd9, 0xf8, 0xed, 0x79, 0xb3, 0xf1, 0xdd, 0x8b, 0xe6, 0xc4, 0xd3, 0x17, 0xcd, 0x89, 0x5f, 0x5e,
	0x34, 0x27, 0x1e, 0xbe, 0xff, 0x0f, 0x89, 0x83, 0xd6, 0xc9, 0xe7, 0xae, 0x7d, 0x54, 0x82, 0x39,
	0x9c, 0xf4, 0x5f, 0xa6, 0xef, 0xfe, 0x11, 0x00, 0x00, 0xff, 0xff, 0xc2, 0x23, 0x6b, 0xbb, 0x08,
	0x0f, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CNorm.Size()
		i -= size
		if _, err := m.CNorm.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	{
		size := m.FTolerance.Size()
		i -= size
		if _, err := m.FTolerance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	{
		size := m.CRewardForecast.Size()
		i -= size
		if _, err := m.CRewardForecast.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xda
	{
		size := m.CRewardInference.Size()
		i -= size
		if _, err := m.CRewardInference.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd2
	{
		size := m.PRewardReputer.Size()
		i -= size
		if _, err := m.PRewardReputer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xca
	{
		size := m.PRewardForecast.Size()
		i -= size
		if _, err := m.PRewardForecast.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xc2
	{
		size := m.PRewardInference.Size()
		i -= size
		if _, err := m.PRewardInference.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xba
	if m.BlocksPerMonth != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.BlocksPerMonth))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.MinEpochLengthRecordLimit != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinEpochLengthRecordLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.MaxLimit != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.DefaultLimit != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DefaultLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x92
	if m.MaxTopicPages != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTopicPages))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.TopicPageLimit != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopicPageLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.MaxRetriesToFulfilNoncesReputer != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxRetriesToFulfilNoncesReputer))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.MaxRetriesToFulfilNoncesWorker != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxRetriesToFulfilNoncesWorker))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.GradientDescentMaxIters != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GradientDescentMaxIters))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	{
		size := m.SigmoidB.Size()
		i -= size
		if _, err := m.SigmoidB.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	{
		size := m.SigmoidA.Size()
		i -= size
		if _, err := m.SigmoidA.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	{
		size := m.CreateTopicFee.Size()
		i -= size
		if _, err := m.CreateTopicFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	if m.MaxTopReputersToReward != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTopReputersToReward))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxTopForecastersToReward != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTopForecastersToReward))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.MaxTopInferersToReward != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTopInferersToReward))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.MaxSamplesToScaleScores != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxSamplesToScaleScores))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	{
		size := m.ValidatorsVsAlloraPercentReward.Size()
		i -= size
		if _, err := m.ValidatorsVsAlloraPercentReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size := m.TaskRewardAlpha.Size()
		i -= size
		if _, err := m.TaskRewardAlpha.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	{
		size := m.TopicRewardAlpha.Size()
		i -= size
		if _, err := m.TopicRewardAlpha.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size := m.TopicRewardFeeRevenueImportance.Size()
		i -= size
		if _, err := m.TopicRewardFeeRevenueImportance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size := m.TopicRewardStakeImportance.Size()
		i -= size
		if _, err := m.TopicRewardStakeImportance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.MaxUnfulfilledReputerRequests != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxUnfulfilledReputerRequests))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.MaxUnfulfilledWorkerRequests != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxUnfulfilledWorkerRequests))
		i--
		dAtA[i] = 0x78
	}
	{
		size := m.AlphaRegret.Size()
		i -= size
		if _, err := m.AlphaRegret.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.Epsilon.Size()
		i -= size
		if _, err := m.Epsilon.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MinStakeFraction.Size()
		i -= size
		if _, err := m.MinStakeFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MaxGradientThreshold.Size()
		i -= size
		if _, err := m.MaxGradientThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.LearningRate.Size()
		i -= size
		if _, err := m.LearningRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.BetaEntropy.Size()
		i -= size
		if _, err := m.BetaEntropy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.MinEpochLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinEpochLength))
		i--
		dAtA[i] = 0x40
	}
	if m.RemoveStakeDelayWindow != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RemoveStakeDelayWindow))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.RequiredMinimumStake.Size()
		i -= size
		if _, err := m.RequiredMinimumStake.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxMissingInferencePercent.Size()
		i -= size
		if _, err := m.MaxMissingInferencePercent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.MaxTopicsPerBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTopicsPerBlock))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MinTopicWeight.Size()
		i -= size
		if _, err := m.MinTopicWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MaxSerializedMsgLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxSerializedMsgLength))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintParams(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MaxSerializedMsgLength != 0 {
		n += 1 + sovParams(uint64(m.MaxSerializedMsgLength))
	}
	l = m.MinTopicWeight.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.MaxTopicsPerBlock != 0 {
		n += 1 + sovParams(uint64(m.MaxTopicsPerBlock))
	}
	l = m.MaxMissingInferencePercent.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.RequiredMinimumStake.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.RemoveStakeDelayWindow != 0 {
		n += 1 + sovParams(uint64(m.RemoveStakeDelayWindow))
	}
	if m.MinEpochLength != 0 {
		n += 1 + sovParams(uint64(m.MinEpochLength))
	}
	l = m.BetaEntropy.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.LearningRate.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MaxGradientThreshold.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MinStakeFraction.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.Epsilon.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.AlphaRegret.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.MaxUnfulfilledWorkerRequests != 0 {
		n += 1 + sovParams(uint64(m.MaxUnfulfilledWorkerRequests))
	}
	if m.MaxUnfulfilledReputerRequests != 0 {
		n += 2 + sovParams(uint64(m.MaxUnfulfilledReputerRequests))
	}
	l = m.TopicRewardStakeImportance.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.TopicRewardFeeRevenueImportance.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.TopicRewardAlpha.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.TaskRewardAlpha.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.ValidatorsVsAlloraPercentReward.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.MaxSamplesToScaleScores != 0 {
		n += 2 + sovParams(uint64(m.MaxSamplesToScaleScores))
	}
	if m.MaxTopInferersToReward != 0 {
		n += 2 + sovParams(uint64(m.MaxTopInferersToReward))
	}
	if m.MaxTopForecastersToReward != 0 {
		n += 2 + sovParams(uint64(m.MaxTopForecastersToReward))
	}
	if m.MaxTopReputersToReward != 0 {
		n += 2 + sovParams(uint64(m.MaxTopReputersToReward))
	}
	l = m.CreateTopicFee.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.SigmoidA.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.SigmoidB.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.GradientDescentMaxIters != 0 {
		n += 2 + sovParams(uint64(m.GradientDescentMaxIters))
	}
	if m.MaxRetriesToFulfilNoncesWorker != 0 {
		n += 2 + sovParams(uint64(m.MaxRetriesToFulfilNoncesWorker))
	}
	if m.MaxRetriesToFulfilNoncesReputer != 0 {
		n += 2 + sovParams(uint64(m.MaxRetriesToFulfilNoncesReputer))
	}
	if m.TopicPageLimit != 0 {
		n += 2 + sovParams(uint64(m.TopicPageLimit))
	}
	if m.MaxTopicPages != 0 {
		n += 2 + sovParams(uint64(m.MaxTopicPages))
	}
	l = m.RegistrationFee.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.DefaultLimit != 0 {
		n += 2 + sovParams(uint64(m.DefaultLimit))
	}
	if m.MaxLimit != 0 {
		n += 2 + sovParams(uint64(m.MaxLimit))
	}
	if m.MinEpochLengthRecordLimit != 0 {
		n += 2 + sovParams(uint64(m.MinEpochLengthRecordLimit))
	}
	if m.BlocksPerMonth != 0 {
		n += 2 + sovParams(uint64(m.BlocksPerMonth))
	}
	l = m.PRewardInference.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.PRewardForecast.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.PRewardReputer.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.CRewardInference.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.CRewardForecast.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.FTolerance.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.CNorm.Size()
	n += 2 + l + sovParams(uint64(l))
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSerializedMsgLength", wireType)
			}
			m.MaxSerializedMsgLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSerializedMsgLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTopicWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTopicWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTopicsPerBlock", wireType)
			}
			m.MaxTopicsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTopicsPerBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMissingInferencePercent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxMissingInferencePercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredMinimumStake", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequiredMinimumStake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveStakeDelayWindow", wireType)
			}
			m.RemoveStakeDelayWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoveStakeDelayWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEpochLength", wireType)
			}
			m.MinEpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEpochLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetaEntropy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BetaEntropy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LearningRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGradientThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxGradientThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStakeFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinStakeFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epsilon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Epsilon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlphaRegret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AlphaRegret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnfulfilledWorkerRequests", wireType)
			}
			m.MaxUnfulfilledWorkerRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnfulfilledWorkerRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnfulfilledReputerRequests", wireType)
			}
			m.MaxUnfulfilledReputerRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnfulfilledReputerRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicRewardStakeImportance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TopicRewardStakeImportance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicRewardFeeRevenueImportance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TopicRewardFeeRevenueImportance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicRewardAlpha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TopicRewardAlpha.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskRewardAlpha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskRewardAlpha.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorsVsAlloraPercentReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidatorsVsAlloraPercentReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSamplesToScaleScores", wireType)
			}
			m.MaxSamplesToScaleScores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSamplesToScaleScores |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTopInferersToReward", wireType)
			}
			m.MaxTopInferersToReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTopInferersToReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTopForecastersToReward", wireType)
			}
			m.MaxTopForecastersToReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTopForecastersToReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTopReputersToReward", wireType)
			}
			m.MaxTopReputersToReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTopReputersToReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTopicFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateTopicFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SigmoidA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SigmoidB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientDescentMaxIters", wireType)
			}
			m.GradientDescentMaxIters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GradientDescentMaxIters |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetriesToFulfilNoncesWorker", wireType)
			}
			m.MaxRetriesToFulfilNoncesWorker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetriesToFulfilNoncesWorker |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetriesToFulfilNoncesReputer", wireType)
			}
			m.MaxRetriesToFulfilNoncesReputer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetriesToFulfilNoncesReputer |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicPageLimit", wireType)
			}
			m.TopicPageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicPageLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTopicPages", wireType)
			}
			m.MaxTopicPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTopicPages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLimit", wireType)
			}
			m.DefaultLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLimit", wireType)
			}
			m.MaxLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEpochLengthRecordLimit", wireType)
			}
			m.MinEpochLengthRecordLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEpochLengthRecordLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksPerMonth", wireType)
			}
			m.BlocksPerMonth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksPerMonth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRewardInference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PRewardInference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRewardForecast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PRewardForecast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRewardReputer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PRewardReputer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRewardInference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CRewardInference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRewardForecast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CRewardForecast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTolerance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FTolerance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNorm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CNorm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
